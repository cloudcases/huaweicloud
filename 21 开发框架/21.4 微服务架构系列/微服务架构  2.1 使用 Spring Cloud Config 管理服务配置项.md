# 微服务架构 | 2.1 使用 Spring Cloud Config 管理服务配置项

[![img](https://upload.jianshu.io/users/upload_avatars/26617919/b1873c8a-65e7-40f7-8225-d0dce13b3385.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)](https://www.jianshu.com/u/d3dc1fbf7ed8)

[多氯环己烷](https://www.jianshu.com/u/d3dc1fbf7ed8)[![  ](https://upload.jianshu.io/user_badge/19c2bea4-c7f7-467f-a032-4fed9acbc55d)](https://www.jianshu.com/mobile/creator)关注

0.1152022.01.13 08:38:06字数 2,060阅读 33

# 前言

**参考资料**：
《Spring Microservices in Action》
《Spring Cloud Alibaba 微服务原理与实战》
《B站 尚硅谷 SpringCloud 框架开发教程 周阳》

SpringCloud Config 为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置；

------

# 1. Spring Cloud Config 基础知识点

## 1.1 特点与优缺点

**特点**：

- 非分布式键值存储；
- 提供对 Spring 及非 Spring 服务的紧密集成；
- 可以使用多个后端来存储配置数据；
- 易于搭建和部署使用；
- 与 Spring Boot 紧密集成，可以使用注解完成配置；

## 1.2 config 的 server 端和 client 端

- server 端为分布式配置中心，是一个独立的微服务应用；
- client 端为分布式系统中的基础设置或微服务应用，通过指定配置中心来管理相关的配置；

## 1.3 配置存储

- Spring Cloud Config 支持将配置存储在：git、数据库、svn 以及本地文件；

## 1.4 常用的三种环境配置名称

- **dev**：开发环境；
- **prd**：实际环境；
- **test**：测试环境；
- 一般测试环境是实际环境的 copy；

## 1.5 使用本地文件存储配置的弊端

- 将维护环境的责任放在开发人员身上；

## 1.6 Spring Cloud Config 的作用

- 集中管理配置文件；
- 不同环境不同配置，动态化的配置更新，分环境部署，如：dev/test/prod/beta/release；
- 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息；
- 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置；
- 将配置信息以REST接口的形式暴露；



# 2. 配置服务器的示例

## 2.1 引入 pom.xml 依赖文件



```xml
<!--配置中心服务-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>
```

## 2.2 修改 boostrap.yaml 配置文件

> resources 包下的 boostrap.yaml，为配置服务器自己的配置文件；

- 应用程序配置文件的命名约定是

   

  应用程序名称-环境名称.yml

  ；

  - 其中环境名称可以是：dev(开发环境)、prd(实际环境) 、test(测试环境)；

- 需要启动哪个环境的配置可以用 `profile` 属性指定。没有指定该属性则默认加载 `application.yml` 文件中的配置数据；

### 2.2.1 在本地文件进行配置



```yaml
server:
  port: 8888 #Spring Cloud 配置服务器将要监听的端口
spring:
  application:
    name: xxx-config-server #服务的名称
  profiles:
    active: native #用于存储配置的后端存储库（文件系统）
  cloud:
    config:
      server:
        native:
          search-locations: classpath:/config/ #【重要参数】配置文件的存储位置路径
```

### 2.2.2 在 git 上进行配置

- 需要事先在 github 或 gitee 等 git 工具上建立相应的的配置中心仓库。一个简单示例：[https://gitee.com/dlhjw/config-demo](https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2Fdlhjw%2Fconfig-demo)；
- 其实就是把本地文件的 config 包及包下配置放在 git 仓库里；



```yaml
server:
  port: 8888 #Spring Cloud 配置服务器将要监听的端口
spring:
  application:
    name: xxx-config-server #服务的名称
  cloud:
     config:
        server:
          #使用 git 作为后端存储库
          git:
            uri: https://gitee.com/dlhjw/config-demo #配置文件所在仓库
            username: git 账号
            password: git 密码
            default-label: master #配置文件分支
            search-paths: config  #配置文件所在根目录
            force-pull: true #配置文件目录
```

## 2.3 在主程序类上标注注解

**@EnableConfigServer**：表明该服务是个 config 配置服务器；

**@SpringBootApplication**：表明是一个 Spring Boot 应用；

## 2.4 编写客户端的配置文件

> 在本地 src/main/resources 资源目录下新建一个名为 config 的包，包下的配置文件为客户端的配置文件；

- 这里可以新建这些配置文件：

  - xxx-client-dev.yml：下面第 3 点将用到的客户端配置示例；
  - xxx-client-prd.yml
  - xxx-client-test.yml

- 如下图所示：

  ![img]()

  本地配置文件.png



# 3. 客户端获取服务端配置示例

## 3.1 引入 pom.xml 依赖



```xml
<!--配置中心-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
```

- 因为每个服务都会将相关配置放在配置服务器里，因此该依赖可以添加到父工程里，表示公共依赖；

## 3.2 修改 boostrap.yml 配置文件

- 在 boostrap.yml 下；
- 还记得 《2. 服务配置管理》中的 boostrap.yml 的特点吗？说的就是这里。
  - 即：使用 Spring Cloud Config 配置中心时，需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；
  - 具体来说，指以下两个属性：
    - `spring.application.name`：指定了客户端的名称（xxx-client）；
    - `spring.profiles.active`：指定了所需配置的环境（dev）；
  - 由这两个属性即可找到配置服务器 config 包下的 xxx-client-dev.yml 配置文件；

### 3.2.1 服务器使用本地文件方式存储配置



```yaml
spring:
  application:
    name: xxx-client #客户端，使用服务器里的配置
  profiles:
    active: dev #指定当前环境为开发环境
  cloud:
    config:
      fail-fast: true
      #通过 uri 方式获取 config 配置服务器的位置
      #uri: http://localhost:8888
      discovery:
        service-id: xxx-config-server #通过服务发现的方式获取 config 配置服务器
        enabled: true
      profile: ${spring.profiles.active}  #用于定位配置信息，使用上面 spring.profiles.active 属性的值 dev
      label: ${spring.profiles.active} #本地存储，该参数无用
---
spring:
  profiles: dev
eureka:
  instance:
    prefer-ip-address: true
    lease-renewal-interval-in-seconds: 5
    lease-expiration-duration-in-seconds: 20
    metadata-map:
      version: v1.0
  client:
    serviceUrl:
      defaultZone: http://localhost:1025/eureka
    registry-fetch-interval-seconds: 10
---
spring:
  profiles: prd
eureka:
  instance:
    prefer-ip-address: true
    metadata-map:
      version: v1.0
  client:
    serviceUrl:
      defaultZone: http://{实际环境地址}:1025/eureka
```

### 3.2.2 服务器使用 git 方式存储配置



```yaml
spring:
  application:
    name: xxx-client #客户端，使用服务器里的配置
  profiles:
    active: dev #指定当前环境为 dev 开发环境
  cloud:
    config:
      fail-fast: true
      #通过 uri 方式获取 config 配置服务器的位置
      uri: http://localhost:8888 #这里也可以使用服务发现机制
      profile: ${spring.profiles.active}  #用于定位配置信息，使用上面 spring.profiles.active 属性的值 dev
      label: master #对应 git 的分支
---
# 下同上 3.2.1 点里的下半部分，这里省略
```

## 3.3 客户端获取服务端配置的流程

### 3.3.1 本地配置的读取流程

![img]()

本地配置的读取流程.png

- 客户端服务启动后，客户端通过 uri 或服务发现机制找到配置服务器；
- 配置服务器根据客户端的 `spring.application.name` 与 `spring.profiles.active` 找到配置服务器的 config 包下的配置文件的 xxx-client-dev.yml；



# 4. 动态刷新服务的配置

## 4.1 使用 @RefreshScope 注解

- Spring Boot Actuator 提供了一个 **@RefreshScope** 注解，允许开发团队访问 `/refresh` 端点，强制 Spring Boot 应用程序重新读取应用程序配置;
- 该注解加在客户端 client 的主程序类上；



```java
@SpringBootApplication
@RefreshScope
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

## 4.2 刷新微服务配置的几种方式

- 使用 Spring Cloud Bus 的**推送**机制，告诉所有客户端有配置发生更改的**消息**。需要一个额外的中间件（如：RabbitMQ）运行，但 Consul 注册中心不支持这种推送机制；
- 使用 Spring Boot Actuator 提供的 **@RefreshScope** 注解；
- 重新启动所有服务器或容器；



# 5. 使用 Spring Cloud Config 加密敏感配置信息

## 5.1 下载并安装加密所需的 Oracle JCE jar

- 该 jar 包无法通过 Maven下载，必须从 Oracle 公司下载；
- 下载包含 JCE jar 的 zip文件后，必须执行以下操作：
  - 切换到 `$JAVA_HOME/jre/lib/security` 文件夹；
  - 将 `$JAVA_HOME/jre/lib/security` 目录中的 local_policy.jar 和 US_export_policy.jar 文件备份到其他位置；
  - 解压从 Oracle下载的 JCE zip文件；
  - 将 local_policy.jar 和 US_export _policy.jar 复制到 `$JAVA_HOME/jre/lib/security` 目录中；
  - 配置 Spring Cloud Config 以使用加密；

## 5.2 创建加密密钥

- 需要始终将 **ENCRYPT_KEY** 环境变量设置为：`export ENCRYPT_KEY=IMSYMMETRIC`；
- 关于对称密钥，要注意以下两点：
  - 对称密钥的长度应该是 12 个或更多个字符，最好是一个随机的字符集；
  - 不要丢失对称密钥。一旦使用加密密钥加密某些东西，如果没有对称密钥就无法解密；

## 5.3 加密和解密属性

- 加密

   

  ```
  encrypt
  ```

  ：

  - 使用 POST 请求发送：[http://localhost:8888/encrypt](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8888%2Fencrypt)，消息体为需要加密的值 x，即可得到加密后的结果 result；

- 解密

   

  ```
  decrypt
  ```

  ：

  - 使用 POST 请求发送：[http://localhost:8888/decrypt](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8888%2Fdecrypt)，消息体为需要解密的值 result，即可得到解密后的结果 x；

- 使用在配置文件中替换 x 即可使用加密值：

  - `spring.database.password:"{cipher}result"`；

- 默认情况下：在完成上述操作后，配置文件得到加密。但可以在配置服务器的 controller 中定义获取配置文件的接口，该接口返回的是经过加密、解密后的数据；

- 因此，需要《5.4 配置微服务以在客户端使用加密》；

## 5.4 配置微服务以在客户端使用加密

- 配置 Spring Cloud Config 不要在服务器端解密属性；

  - `spring.cloud.config.server.encrypt.enabled=false`
  - 在客户端服务器上设置对称密钥；
  - 将 `spring-security-rsa JAR` 添加到客户端服务的 `pom.xml` 文件中；

  

  ```xml
  <dependency> 
    <groupld>org.springframework.security</groupld>
    <artifactld>spring-security-rsa</artifactld> 
  </dependency>
  ```

- 这样，调用配置服务器的 controller 中定义获取配置文件的接口时，返回的数据是加密的；