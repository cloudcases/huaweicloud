# 微服务架构学习笔记之一认证和授权

[![img](https://upload.jianshu.io/users/upload_avatars/26955/37de032b3a4a?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)](https://www.jianshu.com/u/a659b9c03f3e)

[可文分身](https://www.jianshu.com/u/a659b9c03f3e)关注

2018.08.08 16:46:07字数 2,462阅读 14,458

我们在搭建微服务的时候，常常需要考虑的一个问题是，微服务之间以及你的应用和微服务之间是怎么信任对方的。

这个时候我们会谈到两个概念，认证(authentication)和授权(authorization)。这是两个不同的概念，通俗点讲，认证是指系统需要确认***你是谁？\***，而授权是指在通过认证之后，***你能干什么？\***，多数场景下这里的“你”指的都是第三方应用程序。

## 认证

说到认证，我们可以先来了解下Http常用的一些认证方式。

### Http Basic认证

其中**最简单的是Http Basic认证方式**，这种认证方式是讲用户名密码按照格式***“用户名:密码”\***通过Base-64编码成一个hash值，然后通过Authorization header传递到服务端，然后服务端再通过同样的Base-64编码方式进行解码成为***“用户名:密码”\***格式进行认证。



```undefined
Authorization: Basic QWxhZGRpbjfdaGVuIHNlc2FtZQ==
```

这种认证方式的缺点就是需要在每个Http请求中将用户名密码在网络中进行传输，很容易被破解。而且如果每个Http请求都需要传输用户凭证的话，被破解的概率越高，所以这种认证方式通常需要结合Https进行使用。

### Http Digest认证

而更为安全一点的认证方式是Http Digest认证方式，它也是通过Authorization header来进行传递的，但是算法会更加复杂和不可逆。



```bash
Authorization: Digest username="abc",
                     realm="testing@bb.com",
                     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                     uri="/index.html",
                     qop=auth,
                     nc=00000001,
                     cnonce="0a4f113b",
                     response="6629fae49393a05397450978507c4ef1",
                     opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

Http Digest的认证过程为，当客户端第一次请求服务端资源时，服务端会返回一个随机数(nonce), 然后客户端会通过多次MD5加密来计算出来response的值 (response=MD5(HA1:nonce:HA2)), 其中HA1=MD5(username:realm:password), HA2=MD5(method:digestURI). 当服务端拿到这个response，那么它会从DB取出用户名密码来做同样的操作来看计算出来的response是否一致，如果一致，则表明认证通过。

这种认证方式也会有一定的局限性，那就是**服务端不能不可逆的加密用户的密码。**

### Cookies & Session

由于上面认证方式的缺陷，所以现在常见的认证方式是只需要在第一次登陆请求中传递用户名密码，服务端在校验结束后生成一个session-id，并将这个session-id和用户关联，然后通过http response的cookie header返回给客户端，客户端只需要存储这个cookie并在后续的请求都带上这个cookie就可以。这样服务端也可以对用户的密码进行不可逆加密后存储。

这样的认证方式也会存在一些问题，比如如果web客户端不允许存储cookie呢？如果服务器down了，那么在cache中存储的session也会丢失。所以一般会采用Token的方式来进行认证，比如JWT。

## 授权

关于授权，现在最流行的就是OAuth2了，它是一个授权框架而不是一个认证框架，它的一个目的就是为了减少在各个请求中用户名密码的传递。关于什么是OAuth2，这里有一篇最简向导可以很快帮助你理解什么是OAuth2 - [The Simplest Guide To OAuth 2.0](https://medium.com/@darutk/the-simplest-guide-to-oauth-2-0-8c71bd9a15bb)。而关于OAuth2的几种workflow，上面那篇最简向导的作者也写了一篇，以图例的方式很详细的介绍了OAuth2实现的几种workflow - [Diagrams And Movies Of All The OAuth 2.0 Flows](https://medium.com/@darutk/diagrams-and-movies-of-all-the-oauth-2-0-flows-194f3c3ade85)

当我们知道了什么是OAuth2以及它的几种workflow后，我们就需要知道什么样的情况下需要采用哪种workflow。在极客时间的杨波老师给了一个流程图来帮助判断什么样的场景下需要采用哪种OAuth2的workflow，



![img](https://upload-images.jianshu.io/upload_images/26955-1a262ac4bda1b7cd.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

如何选择OAuth2的workflow

### 授权服务器(Authorization Server)

![img](https://upload-images.jianshu.io/upload_images/26955-480da9017ce98b44.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)

authorization_code_flow.png

在OAuth2的四大角色中，我们最不熟悉的就是授权服务器了。因为app以及resource server就是我们平常开发的前端和后端，app会访问resource server的REST API去获取数据来展示。而授权服务器会是什么？它需要我们自己实现吗？

其实在微服务架构中，一般都需要有自己的一个授权服务器，它的作用主要是分发token给不同的调用方，然后它们可以使用这个token去访问相应的微服务。

我们可以把授权服务器看成是提供一组REST API的service：

1. 授权API(/oauth/authorize) - 这个API会对调用方请求进行授权，返回一个authorization code。
2. 获取Token API(/oauth/token) - 这个API会根据客户请求传入的authorization code来生成一个access token并返回。
3. 校验Token API(/oauth/introspect) - 这个API一般会是resource server用来校验请求方的access token是否有效。
4. 撤销Token API(/oauth/revoke) - 这个API 会把access token直接撤销。

大多数情况下我们都需要实现自己的authentication server，好在spring 框架提供了一个基于spring security 的oauth框架来帮助实现对应的authentication server, resource server 以及client。



![img](https://upload-images.jianshu.io/upload_images/26955-ca475a055e8336b6.png?imageMogr2/auto-orient/strip|imageView2/2/w/904/format/webp)

spring-oauth.png

从上图可以看到，对于spring security提供的默认authorization server的默认实现，其实就是提供了两个endpoint - TokenEndpoint (提供/oauth/token api)和 AuthorizationEndpoint(提供/oauth/authorize api).

### Authorization Server和Resource Server 实战

下面我们可以用spring boot来实现一个authorization server。注意：spring boot版本选用1.5.2.RELEASE 版本。

首先生成一个Springboot 工程，下面是运行主类和build.gradle 配置。



```java
@SpringBootApplication
public class AuthserverApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthserverApplication.class, args);
    }
}
```

build.gradle



```bash
buildscript {
    ext {
        springBootVersion = '1.5.2.RELEASE'
    }
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

apply plugin: 'java'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

group = 'com.interview.authorization'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
    mavenCentral()
}


dependencies {
    compile('org.springframework.boot:spring-boot-starter-security')
    compile('org.springframework.boot:spring-boot-starter-web')
    compile('org.springframework.security.oauth:spring-security-oauth2')

    testCompile('org.springframework.boot:spring-boot-starter-test')
    testCompile('org.springframework.security:spring-security-test')
}
```

上面的依赖文件主要是添加了spring security 和 spring security oauth2的依赖包。

接下来是enable authorization server的配置类，



```java
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory().withClient("clientapp")
                .secret("123456").authorizedGrantTypes("authorization_code")
                .redirectUris("http://localhost:9000/callback").scopes("read_users");
    }
}
```

这里主要使用了@EnableAuthorizationServer注解来告诉spring框架自动配置一些关于AuthorizationEndpoint以及一些关于AuthorizationServer security的配置。同时，来配置访问的client的一些细节，

1. client - 实际上就是client id，要访问resource server的client，比如说mobile app or web page等等。
2. secret - 对应client的secret
3. grant type - 指的是实现oauth2的那几种workflow，authorization_code, implicit, password, client_credential
4. scopes - 授权的范围，可以自己定义一些字符串来表示。

最后需要在*application.properties*里面配置上访问/oauth/authorize 接口时需要的用户凭证 - 实际上就是resource owner的用户名，密码。



```undefined
security.user.name=kevin
security.user.password=123
```

接下来我们可以启动spring boot程序，**然后我们可以通过浏览器模拟client进行/oauth/authorize API的访问**，



```ruby
http://localhost:9090/oauth/authorize?client_id=clientapp&redirect_uri=http://localhost:9000/callback&response_type=code&scope=read_users
```

这时浏览器会提示输入用户的用户名和密码，就是我们配置在application.properties文件里面的username和password。

![img](https://upload-images.jianshu.io/upload_images/26955-0babacfb501ef5ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/928/format/webp)

authentication-user.png

输入用户名密码后，Authorization Server会跳转到一个授权界面：



![img](https://upload-images.jianshu.io/upload_images/26955-e2a65c15c6b4d77e.png?imageMogr2/auto-orient/strip|imageView2/2/w/592/format/webp)

oauth_approval.png

当你确认授权后会自动跳转到callback url 并附带一个authorization code，



```cpp
http://localhost:9000/callback?code=1TRZMN
```

拿到authorization code之后，我们可以通过postman来模拟发送POST请求到/oauth/token接口，



```ruby
http://localhost:9090/oauth/token?code=1TRZMN&grant_type=authorization_code&redirect_uri=http://localhost:9000/callback&scope=read_users
```

同时要加上Authorization Header，采用的是basic的验证方式，用户名密码则是配置在AuthorizationServerConfiguration类里面的client和secret.

![img](https://upload-images.jianshu.io/upload_images/26955-3690dc19926f33d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

authorization-header.png

最后可以拿到用于访问resource server的access token：



```json
{
    "access_token": "823c7d7e-8294-4288-b4c3-46358ccff0fd",
    "token_type": "bearer",
    "expires_in": 32884,
    "scope": "read_users"
}
```

接下来我们就可以创建我们的resource server了，它所依赖的lib跟authorization server一样，



```bash
dependencies {
    compile('org.springframework.boot:spring-boot-starter-security')
    compile('org.springframework.boot:spring-boot-starter-web')
    compile('org.springframework.security.oauth:spring-security-oauth2')
    testCompile('org.springframework.boot:spring-boot-starter-test')
    testCompile('org.springframework.security:spring-security-test')
}
```

同时，resource server本身会暴露一些REST API给client 调用，这个就是我们需要保护的资源，也就是说，在访问/api/users API时，需要通过oauth2认证才可以调用该API，如下：



```csharp
@RestController
public class UserRestAPI {

    @RequestMapping("/api/users")
    public ResponseEntity<List<User>> getUsers(){
        List<User> users = new ArrayList<User>();
        users.add(new User("kevin",33));
        users.add(new User("joe",30));
        return ResponseEntity.ok(users);
    }
}

public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

接下来我们会配置关于resource server的配置，



```java
@Configuration
@EnableResourceServer
public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().anyRequest().authenticated()
            .and().requestMatchers().antMatchers("/api/**");
    }

    @Primary
    @Bean
    public RemoteTokenServices tokenService(){
        RemoteTokenServices remoteTokenServices = new RemoteTokenServices();
        remoteTokenServices.setCheckTokenEndpointUrl("http://localhost:9090/oauth/check_token");
        remoteTokenServices.setClientId("clientapp");
        remoteTokenServices.setClientSecret("123456");
        return remoteTokenServices;
    }
}
```

首先是使用@EnableResourceServer注解，它会告诉spring框架自动配置一些关于resource server的配置，比如启用OAuth2AuthenticationProcessingFilter来检查进来的request有没有有效的accesstoken。

其次，我们需要配置那些request，那些API需要被认证后才能被访问。

最后，我们自己定义了一个RemoteTokenServices, 这个是用来跟Authorization Server进行打交道的，主要是用来校验发到resource server的accesstoken是否有效。在这个RemoteTokenServices中，我们需要传递clientId和clientSecret作为basic认证（Authorization Server需要), 它也指定了Authorization Server在哪里，需要访问的CheckTokenURL是什么。

如果这个时候你去访问resource server的API - /api/users 你会得到一个403 forbidden。因为你还没有在Authorization Server里面配置/oauth/check_token的访问权限，默认是"denyAll".



```java
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory().withClient("clientapp")
                .secret("123456").authorizedGrantTypes("authorization_code")
                .redirectUris("http://localhost:9000/callback").scopes("read_users");
    }

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.checkTokenAccess("isAuthenticated()");
    }
}
```

上面配置了/oauth/check_token的访问权限为必须是认证过的用户才可以访问 - `security.checkTokenAccess("isAuthenticated()");`
这个时候再去调用http://localhost:9091/api/users 就会返回正确的数据。

![img](https://upload-images.jianshu.io/upload_images/26955-1e60cb3cc49bc7e1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

/api/users 调用结果

## JWT token

在上面的实战中，可以看到，每次resource server在拿到access token后都需要连接到authorization server去检查access token是否有效。为了支持在resource server中进行access token的自校验，我们可以使用JWT token。同时，JWT token还可以包含更多的元数据，可以是自己定义的，比如userId等这些不敏感的信息。想要了解JWT token的一些细节，可以参考 [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)。

## 参考文档

[spring-security-oauth2参考文档](https://projects.spring.io/spring-security-oauth/docs/oauth2.html)
[微服务架构实战](https://time.geekbang.org/course/intro/84)
[登陆工程:传统Web应用中的身份验证技术](http://insights.thoughtworkers.org/traditional-web-app-authentication/)



[微服务架构学习笔记之一认证和授权 - 简书 (jianshu.com)](https://www.jianshu.com/p/8867ea3cd9f7)